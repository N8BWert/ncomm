<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="NComm"><title>ncomm - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ncomm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../ncomm/index.html">ncomm</a><span class="version">1.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">ncomm</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/ncomm/lib.rs.html#1-105">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="ncomm"><a class="doc-anchor" href="#ncomm">§</a>NComm</h2>
<p>NComm is a robotics framework designed for developing large parallel robotics projects.</p>
<h3 id="description"><a class="doc-anchor" href="#description">§</a>Description</h3>
<p>The idea behind NComm is that the robotics framework should provide structure and communication primitives but, other than that, the user should be free to use whatever they want.</p>
<h3 id="technical-overview"><a class="doc-anchor" href="#technical-overview">§</a>Technical Overview</h3>
<p>In NComm (like Ros) a single “task” or unit of work is considered a Node.  In NComm, nodes implement the Node interface which defines specific actions and properties of a node.</p>
<p>For example, imagine a single unit of work that receives sensor data and is responsible for performing fusion on the various pieces of sensor data.  This node would typically look something like:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub struct </span>SensorFusionNode {
    <span class="comment">// Sensor subscribers
    </span>temperature_sensor_subscriber,
    imu_sensor_subscriber,
    ...

    <span class="comment">// Data publishers
    </span>state_estimation_publisher,
}</code></pre></div>
<p>Then implementing the Node interface for the SensorFusionNode requires specifying an update delay for the node as well as an optional behavior for the node given specific states.  First, I’ll explain what the various states entail.</p>
<h4 id="the-start-state"><a class="doc-anchor" href="#the-start-state">§</a>The <code>Start</code> State</h4>
<p>The start state is run just before normal execution begins.  This makes start the perfect place to perform any necessary initialization logic that must occur before a system begins running.</p>
<p>If the user is familiar with Arduino or Game Development, this is typically notated as <code>void setup()</code> and can be used to configure peripherals before the normal execution of the system begins.</p>
<p>For our SensorFusionNode, the <code>Start</code> state could involve resetting internal state
parameters or publishing an initial known state over the <code>state_estimation_publisher</code>.</p>
<h4 id="the-update-state"><a class="doc-anchor" href="#the-update-state">§</a>The <code>Update</code> State</h4>
<p>The update state is effectively the main operation of a Node.  This method is called every <code>update_delay</code> microseconds and almost certainly contains the actual
runtime functionality or the node.</p>
<p>If the user is familiar with Arduino or Game Development, this is typically notated as <code>void update()</code>.</p>
<p>For our SensorFusionNode, the <code>Update</code> state would involve taking the incoming sensor values, calculating some state estimate and publishing that state estimate via the <code>state_estimate_publisher</code>.</p>
<h4 id="the-shutdown-state"><a class="doc-anchor" href="#the-shutdown-state">§</a>The <code>Shutdown</code> State</h4>
<p>The shutdown state is used to clean up any necessary work that was started during the <code>Update</code> state.  This could involve publishing a final message over the publisher or storing data for the next execution of the system.</p>
<p>For our SensorFusionNode, the <code>Stop</code> state could involve saving the current state estimation to some log file so it can be used when the system begins again.</p>
<h3 id="integrations"><a class="doc-anchor" href="#integrations">§</a>Integrations</h3>
<p>Currently NComm is has integration with the following packages:</p>
<ul>
<li>Rerun - NComm has integration with the Rerun data visualizer as both a publisher and node.  To enable Rerun integration add the feature “rerun” to ncomm, ncomm-nodes, or ncomm-publishers-and-subscribers.</li>
</ul>
<h3 id="features"><a class="doc-anchor" href="#features">§</a>Features</h3>
<p>To allow NComm to have the possibility of being used on as many types of devices as possible I’m using a heavy dose of Rust features to conditionally compile parts of the crates.  Specifically, each crate in the NComm collection has the following features:</p>
<ul>
<li>nostd - Use the nostd feature when running on a target that doesn’t support the Rust standard library (i.e. resource constrained embedded devices)</li>
<li>alloc - Use the alloc feature when running ona target that doesn’t support the Rust standard library but there is some global allocator available so allocating a bit of memory isn’t out of the question.  As a note, this will almost always also include the nostd feature of the crate.  This is because it is impossible to really run Rust without the core library (i.e. no-std) so a lot of the bare necessities of the NComm crate come from the nostd compatibility.</li>
<li>std (default) - The full availability of the Rust standard library is at your disposal.</li>
</ul>
<p>Note: I don’t think there is any reason to have both “alloc” and “nostd” selected at the same time so I would highly recommend doing that as I’m pretty sure weird things will happen.</p>
<p>In addition to the above features, NComm also has the following feature:</p>
<ul>
<li>rerun - Enable Rerun integration support (available in ncomm, ncomm-nodes, and ncomm-publishers-and-subscribers)</li>
<li>rerun-web-viewer - Enable the Rerun web viewer (available in ncomm-nodes)</li>
</ul>
<h3 id="why"><a class="doc-anchor" href="#why">§</a>Why?</h3>
<p>Why NComm?  Well that’s a great question.  I created NComm because I feel like Ros had the right idea it just executed on the idea poorly.  Specifically, I love the idea of Nodes, publishers and subscribers, clients and servers, and action clients and servers but their performance is just plainly laughable in Ros because all types of communication need to be able to be sent between C++ code and Python code.</p>
<p>In addition, I feel like the split of the project across Python and C++ is necessitated by the verbosity of C++ which quickly leads to a split between software developers between the C++ and Python stack.  Additionally, Rust can facilitate incredibly nice zero-cost abstraction that makes it significantly less verbose than C++ while maintaining equal-to-better performance.</p>
<p>Every Rust project would also be amiss if it didn’t mention something about memory safety so here’s that part.  Rust is memory-safe and thread-safe by design (and by association so is NComm).  This means that with NComm you are very unlikely to encounter NREs and other common pitfalls that significantly impede the progress of C++ development.  NComm is also natively thread-safe so on multi-core systems NComm can often execute with significant performance improvements as more cores are added.</p>
<h3 id="future"><a class="doc-anchor" href="#future">§</a>Future</h3>
<p>Currently, NComm is only available on Rust with the <code>std</code> toolchain.  This is fine, but I would love to have <code>no_std</code> versions of the communication primitives for embedded development.  However, I don’t think it is likely I will make <code>no_std</code> executors and instead work on adding communication primitive support to current RTOS’s like RTIC and Embassy (both of which much better than I could likely create on my own).  In general, I would encourage people to add anything they think is missing to this project.  I can already see a possibility for building secure network communication primitives and creating standard nodes for data visualization and logging so I encourage people to build whatever they see fit.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.client_servers"><code>pub use <a class="mod" href="../ncomm_clients_and_servers/index.html" title="mod ncomm_clients_and_servers">ncomm_clients_and_servers</a> as client_servers;</code></div></li><li><div class="item-name" id="reexport.core"><code>pub use <a class="mod" href="../ncomm_core/index.html" title="mod ncomm_core">ncomm_core</a> as core;</code></div></li><li><div class="item-name" id="reexport.executors"><code>pub use ncomm_executors as executors;</code></div></li><li><div class="item-name" id="reexport.nodes"><code>pub use <a class="mod" href="../ncomm_nodes/index.html" title="mod ncomm_nodes">ncomm_nodes</a> as nodes;</code></div></li><li><div class="item-name" id="reexport.pubsubs"><code>pub use ncomm_publishers_and_subscribers as pubsubs;</code></div></li><li><div class="item-name" id="reexport.update_client_servers"><code>pub use <a class="mod" href="../ncomm_update_clients_and_servers/index.html" title="mod ncomm_update_clients_and_servers">ncomm_update_clients_and_servers</a> as update_client_servers;</code></div></li><li><div class="item-name" id="reexport.utils"><code>pub use <a class="mod" href="../ncomm_utils/index.html" title="mod ncomm_utils">ncomm_utils</a> as utils;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod ncomm::prelude">prelude</a></div><div class="desc docblock-short">Re-export of NComm traits to make working with
NComm a bit easier</div></li></ul></section></div></main></body></html>